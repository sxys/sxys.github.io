<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Abel&#39;s Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Abel&#39;s Notes">
<meta property="og:url" content="http://sxys.github.io/index.html">
<meta property="og:site_name" content="Abel&#39;s Notes">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Abel&#39;s Notes">
  
    <link rel="alternate" href="/atom.xml" title="Abel&#39;s Notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Abel&#39;s Notes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">种一颗树最好的时间是十年前</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sxys.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-三个月，从0到1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/04/三个月，从0到1/" class="article-date">
  <time datetime="2017-08-04T03:50:36.000Z" itemprop="datePublished">2017-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/04/三个月，从0到1/">三个月，从0到1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="过去三个月，从0到1"><a href="#过去三个月，从0到1" class="headerlink" title="过去三个月，从0到1"></a>过去三个月，从0到1</h2><ul>
<li>组建团队</li>
</ul>
<p>&emsp;&emsp;1、招聘、面试。</p>
<p>&emsp;&emsp;2、迅速组建团队，前后端主力很快到位。</p>
<ul>
<li>产品设计与分析</li>
</ul>
<p>&emsp;&emsp;1、讨论产品需求、流程设计、第三方合作等等。</p>
<p>&emsp;&emsp;2、讨论金服产品的设计基调，UI细节，交互等等。</p>
<ul>
<li>基础架构设计</li>
</ul>
<p>&emsp;&emsp;1、服务器架构规划</p>
<p>&emsp;&emsp;2、基础JAVA Web架构搭建，采用主流的分布式SOA服务架构Spring、MyBatis、Dubbo等等。</p>
<p>&emsp;&emsp;3、Linux服务器上基础服务搭建，包括缓存服务、数据库服务、文件服务、自动部署工具、反向代理服务、源代码管理服务、接口管理服务等等。</p>
<p>&emsp;&emsp;4、理解需求、拆分系统为三层体系结构，基础表结构和业务表结构设计等等。</p>
<ul>
<li>项目管理</li>
</ul>
<p>&emsp;&emsp;1、分拆工作任务、制定开发计划、推进团队开发进度，确保产品质量和进度。</p>
<p>&emsp;&emsp;2、基础服务统一用户中心已经上线。努力争取金服产品10月份上线。</p>
<ul>
<li>传道授业解惑</li>
</ul>
<p>&emsp;&emsp;1、Linux系统命令、Shell脚本编写、MySQL读写分离、分库分表</p>
<p>&emsp;&emsp;2、Spring、Nginx、Redis、Duboo等开源中间件</p>
<p>&emsp;&emsp;3、定位并解决开发人员碰到的疑难杂症</p>
<h2 id="未来期望"><a href="#未来期望" class="headerlink" title="未来期望"></a>未来期望</h2><p>&emsp;&emsp;1、期望打造一个用户体验流畅，7*24小时高可用、稳定的、可水平、垂直扩展的分布式系统。</p>
<p>&emsp;&emsp;2、锻炼培养一批全栈工程师（Full Stack Engineer）团队。</p>
<h2 id="公司建议"><a href="#公司建议" class="headerlink" title="公司建议"></a>公司建议</h2><ul>
<li><p>加强技术团队实力。</p>
</li>
<li><p>转变思维，传统公司的IT部变成互联网公司，用技术和产品来驱动。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sxys.github.io/2017/08/04/三个月，从0到1/" data-id="cj5xc58zr0000o4nmkztjjkw3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何设计Web上的用户登录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/01/如何设计Web上的用户登录/" class="article-date">
  <time datetime="2017-08-01T02:40:02.000Z" itemprop="datePublished">2017-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/01/如何设计Web上的用户登录/">如何设计Web上的用户登录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Web上的用户登录功能应该是最基本的功能了，可是在我看过一些站点的用户登录功能后，我觉得很有必要写一篇文章教大家怎么来做用户登录功能。下面的文章告诉大家这个功能可能并没有你所想像的那么简单，这是一个关系到用户安全的功能，希望大家能从下面的文章中能知道什么样的方法才是一个好的用户登录功能。</p>
<h2 id="用户名和口令"><a href="#用户名和口令" class="headerlink" title="用户名和口令"></a>用户名和口令</h2><p>&emsp;&emsp;首先，我们先来说说用户名和口令的事。这并不是本站第一次谈论这个事了。如何管理自己的口令让你知道怎么管理自己的口令，破解你的口令让你知道在现代这样速度的计算速度下，用穷举法破解你的口令可能会是一件很轻松的事。在这里我想告诉从开发者的角度上来做设计这个用户名和口令的事。下面一几件规则：</p>
<ul>
<li><p>限用户输入一些非常容易被破解的口令。如什么qwert，123456,password之类，就像twitter限制用户的口令一样做一个口令的黑名单。另外，你可以限制用户口令的长度，是否有大小写，是否有数字，你可以用你的程序做一下校验。当然，这可能会让用户感到很不爽，所以，现在很多网站都提供了UX让用户知道他的口令强度是什么样的（比如这个有趣的UX），这样可以让用户有一个选择，目的就是告诉用户——要想安全，先把口令设得好一点。</p>
</li>
<li><p>千万不要明文保存用户的口令。正如如何管理自己的口令所说的一样，很多时候，用户都会用相同的ID相同的口令来登录很多网站。所以，如果你的网站明文保存的话，那么，如果你的数据被你的不良员工流传出去那对用户是灾难性的。所以，用户的口令一定要加密保存，最好是用不可逆的加密，如MD5或是SHA1之类的有hash算法的不可逆的加密算法。CSDN曾明文保存过用户的口令。（另，对于国内公司的品行以及有关部门的管理方式，我不敢保证国内网站以加密的方式保存你的口令。我觉得，做为一个有良知的人，我们应该加密保存用户的口令）</p>
</li>
<li><p>是否让浏览器保存口令。我们有N多的方法可以不让浏览器保存用户名和口令。但是这可能对用户来说很不爽。因为在真实世界里谁也记得不住那么多的口令。很多用户可能会使用一些密码管理工具来保存密码，浏览器只是其中一种。是否让浏览器保存这个需要你做决定，重点是看一下你的系统的安全级别是否要求比较高，如果是的话，则不要让浏览器保存密码，并在网站明显的位置告诉用户——保存口令最安全的地方只有你的大脑。</p>
</li>
<li><p>口令在网上的传输。因为HTTP是明文协议，所以，用户名和口令在网上也是明文发送的，这个很不安全。你可以看看这篇文章你就明白了。要做到加密传输就必需使用HTTPS协议。但是，在中国还是有很多网站的Web登录方式还在使用ActiveX控件，这可能成为IE6还大量存在的原因。我通常理解为这些ActiveX控件是为了反键盘记录程序的。不过，我依然觉ActiveX控件不应该存在，因为在国外的众多安全很重要的站点上都看不到ActiveX的控件的身影。</p>
</li>
</ul>
<h2 id="用户登录状态"><a href="#用户登录状态" class="headerlink" title="用户登录状态"></a>用户登录状态</h2><p>&emsp;&emsp;首先，我想告诉大家的是，因为HTTP是无状态的协议，也就是说，这个协议是无法记录用户访问状态的，其每次请求都是独立的无关联的，一笔是一笔。而我们的网站都是设计成多个页面的，所在页面跳转过程中我们需要知道用户的状态，尤其是用户登录的状态，这样我们在页面跳转后我们才知道是否可以让用户有权限来操作一些功能或是查看一些数据。</p>
<p>&emsp;&emsp;所以，我们每个页面都需要对用户的身份进行认证。当然，我们不可以让用户在每个页面上输入用户名和口令，这会让用户觉得我们的网站想当的SB。为了实现这一功能，用得最多的技术就是浏览器的cookie，我们会把用户登录的信息存放在客户端的cookie里，这样，我们每个页面都从这个cookie里获得用户是否登录的信息，从而达到记录状态，验证用户的目的。但是，你真的会用cookie吗？下面是使用cookie的一些原则。</p>
<p>&emsp;&emsp;千万不要在cookie中存放用户的密码。加密的密码都不行。因为这个密码可以被人获取并尝试离线穷举。所以，你一定不能把用户的密码保存在cookie中。我看到太多的站点这么干了。</p>
<p>&emsp;&emsp;正确设计“记住密码”。这个功能简直就是一个安全隐患，我觉得并不是所有的程序员都知道怎么设计这个事。下面是一些方法供你参考。</p>
<ol>
<li>在cookie中，保存三个东西——用户名，登录序列，登录token。</li>
</ol>
<p>&emsp;&emsp;用户名：明文存放。</p>
<p>&emsp;&emsp;登录序列：一个被MD5加密过的随机数，每次以输入口令的方式登录后更新。</p>
<p>&emsp;&emsp;登录token：一个被MD5加密过的随机数，仅一个登录session内有效，新的登录session会更新它。</p>
<p>&emsp;&emsp;上述三个东西会存在服务器上，服务器的验证用户需要验证客户端cookie里的这三个事。为什么要设计这个样子？因为，</p>
<p>&emsp;&emsp;a）登录token是单实例登录。意思就是一个用户只能有一个实例。</p>
<p>&emsp;&emsp;b）登录序列是用来做盗用行为检测的。如果用户的cookie被盗后，盗用者使用这个cookie访问网站时，我们的系统是以为是合法用户，然后更新“登录token”，而真正的用户访问时系统发现，只有“用户名”和“登录序列”相同，但是“登录token”不对，这样的话，系统就知道，这个用户出现了被盗用的情况，于是，系统可以清除登录序列和 登录token，这样就可以令所有的cookie失效，并要求用户输入口令。并给警告用户系统安全。</p>
<p>&emsp;&emsp;不要让cookie有权限访问所有的操作。否则就是XSS攻击，这个功能请参看新浪微博的XSS攻击。下面的这些功能一定要用户输入口令：</p>
<p>&emsp;&emsp;1. 修改口令。</p>
<p>&emsp;&emsp;2. 修改电子邮件。（电子邮件通过用来找回用户密码）</p>
<p>&emsp;&emsp;3. 用户的隐私信息。</p>
<p>&emsp;&emsp;4. 用户消费功能。</p>
<h2 id="找回口令的功能"><a href="#找回口令的功能" class="headerlink" title="找回口令的功能"></a>找回口令的功能</h2><p>&emsp;&emsp;找回口令的功能一定要提供。但是很多朋友并不知道怎么来设计这个功能。我们有很多找回口令的设计，下面我逐个点评一下。</p>
<p>&emsp;&emsp;千万不要使用安全问答。事实证明，这个环节很烦人，而且用户并不能很好的设置安全问答。什么，我的生日啊，我母亲的生日，等等。因为今天的互联网和以前不一样了，因为SNS，今天的互联比以前更真实了，我可以上facebook，开心，人人网，LinkedIn 查到你的很多的真实的信息。通过这些信息我可以使用安全问答来重设你的口令。Facebook的安全问答很强大，还要你通过照片认人。</p>
<p>&emsp;&emsp;不要重置用户的密码。因为这有可能让用户的密码遭到恶意攻击。当然，你要发个邮件给用户让其确认，用户点击邮件中的一个链接，你再重置。我并不推荐这样的方法，因为用户一般都会用笔记下来这个很记的口令，然后登录系统，因为登录系统时使用了“记住密码”的功能，所以导致用户不会去修改密码，从而要么导到被写下来的密码被人盗取，要么又忘记了密码。</p>
<p>&emsp;&emsp;好一点的做法——通过邮件自行重置。当用户申请找回口令功能的时候，系统生成一个MD5唯一的随机字串（可通过UID+IP+timestamp+随机数），放在数据库中，然后设置上时限（比如1小时内），给用户发一个邮件，这个连接中包含那个MD5的字串的链接，用户通过点击那个链接来自己重新设置新的口令。</p>
<p>&emsp;&emsp;更好一点的做法——多重认证。比如：通过手机+邮件的方式让用户输入验证码。手机+邮件可能还不把握，因为手机要能会丢了，而我的手机可以访问我的邮箱。所以，使用U盾，SecureID，或是通过人工的方式核实用户身份。当然，这主要看你的系统的安全级别了。</p>
<h2 id="口令探测防守"><a href="#口令探测防守" class="headerlink" title="口令探测防守"></a>口令探测防守</h2><p>&emsp;&emsp;使用验证码。验证码是后台随机产生的一个短暂的验证码，这个验证码一般是一个计算机很难识别的图片。这样就可以防止以程序的方式来尝试用户的口令。事实证明，这是最简单也最有效的方式。当然，总是让用户输入那些肉眼都看不清的验证码的用户体验不好，所以，可以折中一下。比如Google，当他发现一个IP地址发出大量的搜索后，其会要求你输入验证码。当他发现同一个IP注册了3个以上的gmail邮箱后，他需要给你发短信方式或是电话方式的验证码。</p>
<p>&emsp;&emsp;用户口令失败次数。调置口令失败的上限，如果失败过多，则把帐号锁了，需要用户以找回口令的方式来重新激活帐号。但是，这个功能可能会被恶意人使用。最好的方法是，增加其尝试的时间成本（以前的这篇文章说过一个增加时间成本的解密算法）。如，两次口令尝试的间隔是5秒钟。三次以上错误，帐号被临时锁上30秒，5次以上帐号被锁1分钟，10次以上错误帐号被锁4小时……</p>
<p>&emsp;&emsp;系统全局防守。上述的防守只针对某一个别用户。恶意者们深知这一点，所以，他们一般会动用“僵尸网络”轮着尝试一堆用户的口令，所以上述的那种方法可能还不够好。我们需要在系统全局域上监控所有的口令失败的次数。当然，这个需要我们平时没有受到攻击时的数据做为支持。比如你的系统，平均每天有5000次的口令错误的事件，那么你可以认为，当口令错误大幅超过这个数后，而且时间相对集中，就说明有黑客攻击。这个时候你怎么办？一般最常见使用的方法是让所有的用户输错口令后再次尝试的时间成本增加。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://coolshell.cn/articles/5353.html" target="_blank" rel="external">http://coolshell.cn/articles/5353.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sxys.github.io/2017/08/01/如何设计Web上的用户登录/" data-id="cj5xc59010001o4nmvqihoui0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于Token的身份验证" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/31/基于Token的身份验证/" class="article-date">
  <time datetime="2017-07-31T11:51:47.000Z" itemprop="datePublished">2017-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/31/基于Token的身份验证/">基于Token的身份验证</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>&emsp;&emsp;现在很多世界知名大型网站都采用Token身份验证，比如Facebook，Google+，Twitter，GitHub等等，比起传统的身份验证方法，Token扩展性更强，也更安全，非常适合Web应用和移动应用。</p>
<h2 id="Token的主要优点"><a href="#Token的主要优点" class="headerlink" title="Token的主要优点"></a>Token的主要优点</h2><ul>
<li>支持跨越访问</li>
</ul>
<p>&emsp;&emsp;Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。</p>
<ul>
<li>无需存储Session信息</li>
</ul>
<p>&emsp;&emsp;Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。</p>
<ul>
<li>更适合移动应用</li>
</ul>
<p>&emsp;&emsp;当你的客户端是一个原生平台（iOS, Android等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p>
<ul>
<li>性能更好</li>
</ul>
<p>&emsp;&emsp;一次网络往返时间（通过数据库查询session信息）总比做一次签名计算的Token验证和解析要费时得多。</p>
<ul>
<li>基于标准化</li>
</ul>
<p>&emsp;&emsp;你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）</p>
<h2 id="当前流行的身份验证机制"><a href="#当前流行的身份验证机制" class="headerlink" title="当前流行的身份验证机制"></a>当前流行的身份验证机制</h2><p>  先来看看现在主要的身份验证机制</p>
<ul>
<li>Http Basic Auth</li>
</ul>
<p>&emsp;&emsp;HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用。</p>
<ul>
<li>OAuth</li>
</ul>
<p>&emsp;&emsp;OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p>
<p>&emsp;&emsp;OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p>
<p>&emsp;&emsp;这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用互通互联。</p>
<ul>
<li>Cookie Auth</li>
</ul>
<p>&emsp;&emsp;Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。</p>
<ul>
<li><p>Token Auth</p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里，也可能在HTTP的Authorization头中。</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</li>
</ul>
<h2 id="Token验证实现标准JWT"><a href="#Token验证实现标准JWT" class="headerlink" title="Token验证实现标准JWT"></a>Token验证实现标准JWT</h2><p>&emsp;&emsp;JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<p>&emsp;&emsp;JWT官网已经给出所有语言的实现。可以自行下载。</p>
<p>相关链接：</p>
<p><a href="http://jwt.io/" target="_blank" rel="external">JWT官网</a></p>
<p><a href="https://github.com/auth0/jwt-decode" target="_blank" rel="external">https://github.com/auth0/jwt-decode</a></p>
<p><a href="http://www.csdn.net/article/1970-01-01/303589" title="如何设计用户登录" target="_blank" rel="external">http://www.csdn.net/article/1970-01-01/303589</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sxys.github.io/2017/07/31/基于Token的身份验证/" data-id="cj5xc590h0002o4nm0fx9fmd9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/04/三个月，从0到1/">三个月，从0到1</a>
          </li>
        
          <li>
            <a href="/2017/08/01/如何设计Web上的用户登录/">如何设计Web上的用户登录</a>
          </li>
        
          <li>
            <a href="/2017/07/31/基于Token的身份验证/">基于Token的身份验证</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Abel<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>